2510.25249v1 [quant-ph] 29 Oct 2025

arXiv

Encoding computationally hard problems in triangular Rydberg atom arrays

' Thrust

Xi-Wei Pan,! Huan-Hai Zhou,! Yi-Ming Lu,? and Jin-Guo Liu! F]

of Advanced Materials, The Hong Kong University of Science and Technology (Guangzhou), Guangdong, China

2Zhili College, Tsinghua University, Beijing, China
(Dated: October 30, 2025)

Rydberg atom arrays are a promising platform for quantum optimization, encoding computation-
ally hard problems by reducing them to independent set problems with unit-disk graph topology. In
{Nguyen et al., PRX Quantum 4, 010316 (2023)], a systematic and efficient strategy was introduced
to encode multiple problems into a special unit-disk graph: the King’s subgraph. However, King’s
subgraphs are not the optimal choice in two dimensions. Due to the power-law decay of Rydberg
interaction strengths, the approximation to unit-disk graphs in real devices is poor, necessitating
post-processing that lacks physical interpretability. In this work, we develop an encoding scheme that
can universally encode computationally hard problems on triangular lattices, based on our innovative
automated gadget search strategy. Numerical simulations demonstrate that quantum optimization
on triangular lattices reduces independence-constraint violations by approximately two orders of
magnitude compared to King’s subgraphs, substantially alleviating the need for post-processing in

experiments.

Introduction. — Classical algorithms for NP-hard
optimization problems scale exponentially [I}{3], moti-
vating the search for quantum approaches with potential
advantages [4}{10]. Rydberg atom arrays are a promising
platform for quantum optimization, as blockade inter-
actions directly enforce independence constraints [TI}+
{15}. This naturally maps to the maximum indepen-
dent set (MIS) problem on unit-disk graphs—graphs
where vertices are connected if separated by less than
a fixed distance—an NP-hard problem [I6}18]. With
tunable local detunings, this mapping extends to the
maximum weighted independent set (MWIS), also NP-
hard [18] [19]. Recent experiments have even reported
signatures of superlinear quantum speedup for MIS on
King’s subgraphs (KSGs)—a restricted subclass of unit-
disk graphs—with up to 289 qubits [20], highlighting the
central role of KSG embeddings in current Rydberg-
atom implementations.

To make Rydberg atoms useful for practical optimiza-
ion problems, Nguyen et al. [21] introduced the use of
KSGs to encode independent set problems with arbi-
rary connectivity. The key idea is to use gadgets, small
atomic arrangements that locally enforce constraints
while respecting unit-disk connectivity. This approach
has a provably optimal vertex overhead of O(n”), where
n is the number of vertices in the original graph.

The main critique of KSG-based quantum optimiza-
ion [20] (22}24] is that the approximation to unit-disk
graphs is poor, leading to the need for post-processing
hat lacks explainability. In Ref. [20], a significant por-
ion of independence constraints were observed to be
violated, with many output configurations having cardi-
nalities exceeding that of the maximum independent set.
Extensive post-processing, including removing vertices
hat violate the independence constraint and adding
new vertices greedily, is necessary. Partly due to this,
he observed superlinear speedup is not completely con-
vincing.

A convincing demonstration of quantum speedup
should rest on a robust encoding scheme that avoids
post-processing, which could be achieved by changing
the lattice type, e.g., to a triangular lattice. In this
letter, we introduce a key insight: the quality factor
Q = Ruin/Tmax quantifies encoding robustness, where
Rmin is the minimum distance between non-adjacent
atoms and rmax is the maximum distance between adja-
cent atoms. Since Rydberg interactions between atoms
separated by distance r scale as V(r) « 1/r®, the ener-
getic separation between connected and non-connected
pairs scales as Q®. KSGs yield only Q = V2, corre-
sponding to an energetic separation of Q® = 8, whereas
triangular lattices naturally provide Q = V3, giving
Q° = 27—more than three times larger (see Supple-
mental Material for details). This enhanced penalty
substantially suppresses constraint violations and miti-
gates unwanted long-tail effects [23]. The higher quality
factor is also widely believed to be beneficial for quan-
tum simulation of exotic phases [25}27].

Yet, a general encoding scheme for triangular-lattice
subgraphs (TLSGs) is lacking. Here TLSGs refer to
unit-disk graphs constrained to the triangular lattice.
It is even unknown whether MWIS on TLSGs is NP-
hard [3], casting doubt on universal encodability. A key
obstacle is the absence of a systematic gadget-search
framework. In particular, gadgets such as the crossing
gadget serve as fundamental building blocks in encoding
constructions. Ref. [21] identified an optimal 8-vertex
crossing gadget for KSGs, but the brute-force search em-
ployed there quickly becomes infeasible for larger gad-
gets. For TLSGs, no valid crossing gadget had been
reported until now.

g

In this letter, we develop an innovative automated
gadget-search strategy, discover a 12-vertex crossing
gadget for TLSGs, construct a universal encoding for
NP-hard problems using this gadget, and numerically
show that independence-constraint violations are re-

duced by nearly two orders of magnitude compared
with KSG encodings. These results suggest that post-
processing may be unnecessary for TLSG encodings.
Encoding scheme. — The MIS or MWIS problem on
unit-disk graphs can be cast as a ground-state search for
an effective Hamiltonian implemented by Rydberg atom
arrays [19][21]. The blockade interaction enforces the in-
dependence constraint by forbidding simultaneous exci-
tations of nearby atoms, while detunings encode vertex
weights. Let A, denote the detuning of atom v and Ry
the blockade radius. The effective classical Hamiltonian

> CONN», (1)

[ru-re|<Ry

H=-S Ayn, +

where n, is the number operator of atom v, and r, and
r, are the atomic positions. The infinite interaction
crudely approximates the fast-decaying van der Waals
potential ~ 1/r® and enforces the hard constraint.

Since many computational problems can be reduced
to MIS or MWIS on graphs [28], a central challenge
is encoding graphs with arbitrary connectivity into
hardware-native unit-disk geometries. In this letter, we
focus on the TLSG and propose an efficient encoding
framework.

Consider a general graph G = (V, E) with vertex set
V and edge set E.

Theorem 1. The problem of finding a maximum in-
dependent set on a general graph G = (V,E) can be
encoded into that on a TLSG with O(|V |?) vertices.

Proof. We prove this theorem by constructing a two-
step mapping scheme, illustrated in Fig. In Step 1,
each logical vertex of the source graph G = (V,£) is
replaced by a vertex wire consisting of O(|V|) vertices,
corresponding to the copy gadget in Ref. [21]. The col-
ection of these vertex wires forms a two-dimensional
crossing lattice, where crossings occur at specific sites
or any (u,v) € E. Vertices with odd indices along
he same wire represent equivalent copies of the same
source vertex, allowing an edge in the source graph to
be redistributed to any pair of equivalent vertices. The
redistributed edges, shown as red lines in Fig[i{b), are
placed at the crossings of the lattice.

In Step 2, we use specialized gadgets with con-
stant size to replace crossings in the crossing lattice
(Fig. [ifc)), ensuring that all vertices respect the unit-
disk constraint, while preserving the solution equiva-
ence. Details on how to design such gadgets are dis-
cussed in the following section. The generated graph
can be further simplified, e.g., by trimming the dan-
gling legs. The resulting TLSG encoding is shown in
Fig. fi), with further details provided in the Supple-
mental Material.

For a graph with n vertices, our TLSG encoding
scheme introduces an overhead of at most O(8n?) ver-

tices (see Supplemental Material for details), some-
what higher than the O(4n”) reported for KSG encod-
ings 21) 29], but still quadratic. Potential optimiza-
tions, such as vertex reordering [21] and further simpli-
fications, can reduce the required number of atoms.
Gadget finding. — This section introduces the gad-
get search methodology, applicable to graphs both with
and without geometric constraints, including, but not
limited to, TLSGs.
A gadget is a small positive-weighted graph whose
MWIS ground states realize a prescribed logical rela-
tion among a selected subset of vertices. Such relation
can be expressed as a k-variable logical constraint with
satisfying set £ C {0,1}*. For example, a 2-to-1 AND
gadget encodes the constraint £ = {000,010, 100, 111}.
Gadgets are basic building blocks in our encoding
scheme due to their composability 21]: MWIS ground
states of multiple gadgets can be combined to real-
ize conjunctions of multiple logical constraints (see

Fig. 2{d)).

Definition 1 (Logical equivalence). Let Ge =
(V,E,A) be a weighted graph with positive vertex
weights A = {Ay}vev, and let P = {pi,p2,..., pe} CV
be an ordered set of pin vertices.

For each MWIS M CV, define the pin-projection

me(M; aie PREM yaw.
0, p€ M,

The set of projected MWIS configurations is
Miiwis(Ge) = {te(M) | M € Muwis(Ge)} C {0,1}.

We say the MWIS solutions of G'¢ are logically equiv-
alent on P to a k-variable logical constraint £ C {0, 1}*

if
Mirwis(Ge) = £.

Definition 2 (Gadget). A gadget for a logical con-
straint L is a positive-weighted graph Gc = (V,E, A)
with designated pins P C V such that its MWIS solu-
tions are logically equivalent to L on P. In particular,
the gadget must be non-degenerate, meaning that each
assignment in L corresponds to exactly one MWIS so-
lution.

Proposition 1 (MWIS is maximal). For any positive-
weighted graph G = (V,E,A), a MWIS is always max-
imal; that is, no additional vertex can be added without
violating independence.

Proof. If a MWIS M were not maximal, there would
exist a vertex u € V \ M with no neighbors in M. Then
M U {u} is independent and has strictly larger weight
than M, contradicting maximality. Hence, every MWIS
is maximal.

(a) Computational problem

SQ

Ye © DO

Maximum Independent
Set of K3

(b) Create crossing lattice

(c) Apply gadget replacement and simplification

Weights: O 6 © 26 @ 35 © Overlapping vertices

FIG. 1. Procedure for encoding a MWIS/MIS problem on an arbitrary graph into MWIS on a TLSG, enabling optimization
using programmable Rydberg atom arrays. (a) Example problem: finding MIS of K23 graph. (b) Extend each vertex to a
copy gadget and form a crossing lattice; numbers label equivalent copies of the same source vertex, and red edges indicate
the original-graph connections. (c) Replace the substructures that violate the unit-disk constraint by logically equivalent
gadgets. The gadgets and their composition rule are detailed in Fig. (d) Final encoding of K2,3; the solution to the
original problem is inferred from the ground state configuration of the numbered nodes.

Given a target logical constraint £ C {0,1}* and a
candidate graph space G (e.g., unit-disk graphs on a tri-
angular lattice), we assign a designated set of vertices
pr} C V in each candidate graph G € G.
For each candidate graph, we enumerate its maximal
independent sets M (see Proposition[I) and extract the
subset Mimin C M that is sufficient to realize the logi-
cally equivalent condition, i.e., the pin-projected MWIS
configurations match the target constraint. Weights
Ae zy} are then assigned to vertices by solving the
following integer linear program:

Yn € Min, 0’ € M\ Minin

Vn, n’ € Minin.
(2)

These two constraints ensure that all configurations in
M*min acquire identical energies, while every non-target
configuration in M \ Myin is lifted above the ground-
state energy. Optionally, one can minimize 57>, A,
to keep the vertex weights small. Solving this inte-
ger program using a standard solver (e.g., Gurobi [30])
yields feasible weight assignments, and iterating over the

graph space G enables systematic discovery of gadgets
that encode the target logical constraints.

For gadgets on unit-disk graphs such as TLSGs, the
candidate graph space G is generated by applying a
Boolean mask to the triangular lattice. The pin ver-
tices representing logical variables are constrained to lie
on the boundary, ensuring that ancilla vertices do not
form unwanted connections when gadgets are composed.

The gadgets used in Theorem[I]obtained through this
search framework are shown in Fig. Pha-c). In partic-
ular, the crossing gadget on the triangular lattice re-
quires 12 vertices with weights in the range 1 to 4. A
rute-force construction as in Ref. 21] would necessi-
tate enumerating at least 4!? ~ 1.6 x 107 weight alloca-
tions, making the gadget-design computationally infea-
sible. By contrast, our integer-programming approach
finds valid solutions within only a few seconds.

Numerical simulation results -—— To benchmark the
TLSG encoding, we simulate the quantum optimization
process for the encoded Kf2.3 instance shown in Fig [i ds
comparing it against the KSG encoding obtained via
UnitDiskMapping.jl [31] shown in Fig. Bla). We quan-
ify encoding performance using the violation rate—the
per-bond probability that independence constraints are
violated in the final measurement outcomes (details in
Supplemental Material).

In quantum annealing, the system evolves adiabati-
cally under time-varying Rabi frequency (t) and de-

(a) Crossing gadget

(ny =n4) A (ng = N53)

(b) Crossing-with-edge gadget
(my = 14) A (mg = ng) A (nynp = 0)

(c) T-connection gadgets (ny =ng) A (m7 = 0)

(d) Gadget composition

oe — wp

Copy gadget

‘T-connection gadget Weights R dup

Weights: © 6 @25 @35 @45 © Pin vertex

FIG. 2. (a-c) Three essential gadgets for TLSG encoding. In
each subfigure, the left column is the source graph, and the
right column is the mapped graph on a triangular lattice.
The red-framed vertices on the boundary are pin vertices,
and only pin vertices can connect to external vertices. The
full list of gadgets is provided in the Supplemental Material.
(d) The composition of a copy gadget and a T-connection
gadget. This requires summing the weights of the connected
pin vertices at the junction.

uning A(t). Following the experimental protocol of
Ref. [20], we employ unoptimized piecewise-linear ramps
or both parameters. To ensure fair comparison, we
adopt identical parameter strategies for TLSG and KSG
instances: given preset maximum values Qmax and
Amax; the lattice unit a is chosen such that Qmax equals
he geometric mean of interaction Stren at distances
Ce Ce —o

We perform tensor network simulations across various
annealing times (from 0.4 us to 4.0 us) to analyze vio-
ation rate scaling. For detailed parameter setup and
simulation methods, see Supplemental Material.

The key advantage of TLSG encoding lies in its en-
arged operational energy window. As illustrated in
Fig. [{), the annealing pulses must operate within con-
straints imposed by strong interactions at Tmax (main-
aining blockade) and weak interactions at Rmin (avoid-
ing spurious blockade of disconnected atoms). The su-
perior quality factor of TLSG encodings translates di-
rectly to enhanced performance. Figure Bic) demon-
strates that TLSG encoding reduces violation rates
yy nearly two orders of magnitude compared to KSG
encoding. Furthermore, the violation rate exhibits
steeper exponential decay with increasing annealing
ime, demonstrating more effective constraint enforce-
ment by the TLSG encoding. For annealing times ex-
ceeding 3 us, the TLSG violation rate drops below 10~‘,
eliminating post-processing even for state-of-the-art ar-
rays with 6100 atoms [32], as (1 — 1074)®1° ~ 0.543,

Rin and Max, ie, Nnax =

(a)
Weights
fom
0%
b r —
() 3 Ge
S Mmax F a |
ren Sas Se
no ae ee
Fax |
—Amax + —a) | +@+ Triangular
Lo V4 aaa, KS
: an sla : ‘ I
oF cad 10 1 2 3 4
Annealing Time Annealing Time (us)
FIG. 3. Quantum annealing simulations comparing TLSG

and KSG encodings for the K2,3 problem. (a) The KSG
encoding of K2,3 for comparison. The TLSG encoding is
shown in Fig. [if4). (b) Piecewise-linear annealing pulses
for Rabi frequency Q(t) and detuning A(t). The shaded
regions indicate the operational range a <A<

Toax
with Cg = 27 x 862690 MHz pm’. The lattice unit is chosen
so that Qmax equals the geometric mean of the interaction
bounds. (c) Violation rate of independence constraints ver-
sus total annealing time for both encodings. Dashed lines
show exponential fits, and shaded regions denote 95% con-
fidence intervals. The TLSG encoding reduces the violation
rate by nearly two orders of magnitude compared to the KSG

encoding across most annealing regimes.

allowing us to simply discard the illegal configurations
without post-processing.

Conclusions and outlook — Our work establishes
triangular-lattice subgraphs (TLSGs) as superior to
King’s subgraphs for Rydberg quantum optimization.
The enhanced quality factor (Q = V3 vs V2) reduces
constraint violations by nearly two orders of magnitude,
potentially eliminating the need for post-processing. We
contribute two key innovations: (i) the first systematic
MWIS encoding scheme for TLSGs with O(n”) overhead
using crossing-lattice constructions and specialized gad-
gets, and (ii) an automated integer-programming frame-
work for discovering valid gadgets—previously compu-
tationally infeasible. Both are implemented in open-
source Julia packages available online [31] [33].

This framework has the potential to be applied to
other NP-hard problems (graph coloring, dominating
sets, etc.) and alternative platforms (trapped ions [34],
superconducting qubits [35]), broadening quantum op-
timization beyond Rydberg systems.

Acknowledgment — This work was partially sup-
ported by the National Key R&D Program of China
(Grant No. 2024YFB4504004), the National Natural
Science Foundation of China under grant nos. 12404568,
and the Guangzhou Municipal Science and Technology
Project (No. 2024A03J0607).

* finguoliuG@hkust-gz.edu.cn

1] A. Schrijver et al., Combinatorial optimization: polyhe-

dra and efficiency, Vol. 24 (2003).
Kx. Bernhard and J. Vygen, Combinatorial optimization:
Theory and algorithms, ‘Springer, Third Edition, 2005.

2008
3] C. Moore and S. Mertens, The nature of computation

(OUP Oxford, 2011).

4| E. Farhi, J. Goldstone, S. Gutmann, et al.,
tum computation by adiabatic evolution) (2000),
arXiv:quant-ph/0001106 {quant-p:

E. Farhi, J. Goldstone, S. Gutmann, et al., A quan-
tum adiabatic evolution algorithm applied to random
instances of an NP-complete problem,
(2001)

6] T. Kadowaki and H. Nishimori, Quantum annealing in
the transverse ising model, |Physical Review E 58, 5355

(1998)
7| A. Das and B. K. Chakrabarti, Colloquium: Quantum

annealing and analog quantum computation,
Phys. 80, 1061 (2008)

8] T. Albash and D. A. Lidar, Adiabatic quantum compu-

Ci

tation, Rev. Mod. Phys. 90, 015002 (2018
9| E. Farhi, J. Goldstone, and S. Gutmann,

tum approximate optimization

arXiv:1411.4028 [quant-p.

A. Lucas, Ising formulations of many np problems,

Front. in Phys. 2, 5 (2014 |

1] M. Saffman, T. G. Walker, and K. Molmer, Quantum

information with rydberg atoms,

physics 82, 2313 (2010)
H. Pichler, S.-T. Wang, L. Zhou, et al.,

nologies with rydberg atoms, Frontiers in Quantum Sci-
ence and Technology 3, 1426216 (2024)
J. Wurtz, A. Bylinskii, B. Braverman, et al.,

, arXiv:2306.11727 [quant-p!

5] A. Browaeys and T. Lahaye, Many-body physics with
individually controlled rydberg atoms,
6] H. Pichler, S.-T. Wang, L. Zhou, et al.,

complexity of the rydberg le in two dimensions
2018), arXiv:1809.04954 [quant-ph
7| K. Kim, M. Kim, J. Park, et al., Quantum computing
dataset of maximum independent set problem on king

lattice of over hundred rydberg atoms, |Scientific Data!

11, 111 (2024)

8] M. J. A. Schuetz, R. Yalovetzky, R. S. Andrist, et al.,
qredumis: quantum-informed reduction algorithm

‘or the maximum independent set problem) (2025),

A. de Oliveira, E. Diamond-Hitchcock, D. Walker, et al.,

Demonstration of weighted-graph optimization on a

a

rydberg-atom array using local light shifts,
[tim 6, 010501 (2025 6, 010301 (2025)
20] S

21

22

23)

. Ebadi, A. Keesling, M. Cain, e¢ al., Quantum op-

timization of maximum independent set using rydberg
M.-T. Nguyen, J.-G. Liu, J. Wurtz, et al., Quantum
optimization with arbitrary connectivity using rydberg

atom arrays, PRX Quantum 4, 010316 (2023

L. Bombieri, Quantum adi-

. Zeng, R. Tricarico, et al.,
abatic optimization with rydberg arrays: localization

phenomena and encoding strategies, PRX Quantum 6,
020306 (2025

P. Cazals, A. Francois, L. Henriet, et al.,

models with rydberg gadgets, /Physical Review Research

28)

29)

30

(2025).
31] UnitDiskMapping.jl,

L012006 (2025)
i . Benton, Tunable topological protection

Quantum phases of
rydberg atoms on a frustrated triangular-lattice array,
X. Gao, X. Li, and J. Liu, Programming guide for solv-
ing constraint satisfaction problems with tensor net-
works, Chinese Physics B 34, 050201 (2025 |

M. J. Schuetz, R. S. Andrist, G. Salton, et al., Quantum
compilation toolkit for rydberg atom arrays with impli-
cations for problem hardness and quantum speedups,

Physical Review Research 7, 033107 (2025
7 i imizati ', Gurobi Optimizer Refer-

xurobi Optimization,
https: //github.com/

33) getSearch.jl,
GadgetSearch. jl (2025).
34] G. Pagano, A. Bapat, P. Becker, et al.,

QuEraComput ing/UnitDiskMapping. j1 (2025).
. J. Manetsch, G. Nomura, E. Bataille, et al., A
tweezer array with 6100 highly coherent atomic qubits,

Quantum ap-
proximate optimization of the long-range ising model
with a trapped-ion quantum simulator,
the National Academy of Sciences 117, 25396 (2020

35

M. P. Harrigan, K. J. Sung, M. Neeley, et al., Quantum
approximate optimization of non-planar graph problems

on a planar superconducting processor, Nature Physics
17, 332 (2021)
36

the gadgets are named according to their func-
tion, even though their specific implementations may
differ. For example, in Ref. [i], the crossing gadget
enforces (ny = 74) A (ng = 73), and the copy gad-
get contains an even number of vertices. In the present
work, these gadgets may be implemented slightly dif-
ferently—typically differing by a single NOT gadget
per logical variable—but they perform analogous roles
within the crossing lattice.

[37] H. Bernien, S. Schwartz, A. Keesling, et al., Probing

many-body dynamics on a 51-atom quantum simulator,
ature 551, 579 (2017)
[38] C. Bron and J. Kerbosch, Algorithm 457: finding all

cliques of an undirected graph,
ACM 16, 575 (1973)

39| J. Haegeman, J. I. Cirac, T. J. Osborne, et al., Time-
Dependent Variational Principle for Quantum Lattices,
Physical Review Letters 107, 070601 (2011)

Bloqade.jl: Package for the quantum computation and

Al i

. Yang and S. R. White, Time Dependent Variational

Principle with Ancillary Krylov Subspace,
view B 102, 094315 (2020), arXiv:2005.06104 [cond-

mat.

SUPPLEMENTARY MATERIAL: ENCODING COMPUTATIONALLY HARD PROBLEMS IN
TRIANGULAR RYDBERG ATOM ARRAYS

In this supplemental material, we provide detailed technical information and extended discussions that support
the main results presented in the paper.

Section []] introduces the triangular lattice geometry and explains the coordinate transformation convention used
to map between the square-grid representation and the physical triangular lattice. Section [IT] presents the gadget
composition principle, which forms the theoretical foundation for combining individual logical constraints into
complex systems through vertex merging operations. Section [1] describes our systematic methodology for encoding
arbitrary graphs onto triangular-lattice subgraphs (TLSGs)—unit-disk graphs laid out on a triangular lattice.
Section details the algorithmic framework for searching and constructing gadgets that encode specific logical
constraints. Finally, Section [V] describes the numerical simulation setup used to benchmark the performance of our
TLSG encoding against the established King’s subgraph (KSG) approach through quantum annealing simulations.

I. TRIANGULAR LATTICE GEOMETRY AND LAYOUT CONVENTION

In a TLSG with spacing a (Fig. [Si{b)), each vertex has six nearest neighbors at distance a, and the shortest
non-adjacent distance is 3a, hence

Riess V3a -
Qrise = = = V3.
Tmax a
In a King’s graph (KSG) each vertex has eight neighbors (four axial at distance a and four diagonal at distance
J/2a; Fig. a)). Here the largest edge length is rmax = V2a, while the shortest non-edge distance is Rmin = 2a,

giving

Since Rydberg interactions scale as V(r) «x 1/r®, the relevant interaction-scale separation is

Vrevese) _ Qs
VRuin)
so QSicq = 27 versus Qf-gq = 8. In other words, the triangular lattice provides a substantially larger energetic
gap between connected and non-connected atoms, enhancing the robustness of maximum weighted independent set
(MWIS) encodings against spurious long-tail interactions.

In our code implementation, the triangular lattice is represented on a square grid to simplify coordinate assign-
ment. However, this representation distorts the original geometry and requires coordinate transformation.

To recover the physical triangular lattice from the square-grid representation, we perform a coordinate trans-
formation that accounts for both spacing anisotropy and parity-dependent offsets. In this convention, vertices in
odd-numbered columns are shifted vertically by half a lattice spacing (0.5a@), while the horizontal spacing between
columns is scaled by a factor of 3/2. Formally, for an internal coordinate (x,y), the physical coordinates (X,Y)
are

Gy) = (y az, @ [y+ slo mod »)) é (S1)

As a consequence of this layout transformation, horizontal wires (aligned along rows) become zigzag-shaped in
the true triangular lattice, while vertical wires (aligned along columns) remain straight. This distinction affects
gadget design since the geometry and connectivity patterns differ between orientations.

II. GADGET COMPOSITION PRINCIPLE

This section reviews and summarizes the gadget composition principle introduced by Nguyen et al. [2i]. In the
context of the MWIS problem, a NOT gadget can be represented by a simple graph consisting of just two vertices
(a)

va (bt) g
se wae
IWIN

FIG. S1. (a) King’s subgraph (KSG) on a square lattice. (b) Triangular lattice subgraph (TLSG) and the transformation
process between the original triangular lattice and its reshaped square-grid representation used in the code implementation.

with identical weights and a single edge connecting them (Fig. a)). This construction ensures that only one of
the two vertices can be included in any MWIS, effectively encoding the logical negation: if one vertex (representing
a Boolean variable) is selected, the other (representing its negation) must be excluded, and vice versa.

(a) NOT gadget composition
Weights: © 6 Ox.

b= 6

7

+ — > @—O—©O (a=b) A(b=2) sa=c
a=b

=
i
5|
3
i
3
a
fi

FIG. $2. Illustration of how logical conjunction translates to gadget composition in the MWIS framework. (a) Two NOT
gadgets encode the constraints a = b and b = @, and are combined by merging the vertices representing the shared variable
b, ensuring both constraints are enforced simultaneously. (b) shows an extended version where an odd-length vertex wire
is constructed from a sequence of NOT gadgets. Red-framed vertices are equivalent in the MWIS sense, allowing local
information to propagate over long distances.

To illustrate how logical conjunction corresponds to graph composition in the MWIS framework, consider encoding
the two constraints: a = b and b = @, see Figure|S2(a). Each of these constraints can be represented by a simple NOT
gadget. To enforce both constraints simultaneously, the two gadgets must be composed. Since both constraints
involve the same logical variable b, we must identify the two vertices representing 0, i.e., merge v, and vy, into a
single vertex. This merged vertex now participates in both constraints.

From the energy perspective, each gadget originally assigned a weight 6 to its vertex v, (and likewise to vg and
v-). After merging, the shared vertex vp contributes to two energy terms—one from each NOT constraint. Since
the MWIS energy function is additive over vertex weights, the new weight of vp must be updated to 26, reflecting
the combined energetic influence of both constraints on that variable.

In summary, merging two gadgets on a shared logical variable enforces the conjunction of their respective con-
straints. The overlapping vertex inherits the sum of the weights from all participating gadgets, so that the total
MWIS Hamiltonian remains a linear sum of individual gadget energies. Merging vertices does not affect the inde-
pendence constraints, provided that no new edges are introduced, ensuring that each logical constraint contributes
correctly to the total energy. As a result, the ground state of the composite system simultaneously satisfies all
encoded constraints. We summarize the above procedure in the following according to Ref. [21].

Proposition 2 (Gadget composition principle). Let G) = (Vi, £1, A1) and Gg = (V2, Ez, A2) be gadgets that are
logically equivalent on their pin sets P CV, and Q C V2 to logical constraints Ly and Lo, respectively. Let p € P
and q € Q represent the same logical variable. Form the composite graph G by identifying p and q into a single
vertex v and inheriting edges from E, U E2 (updated to reflect the merge). Assume the MWIS objective is additive
in vertex weights and that the merge introduces no edges beyond E, U E,. Define

A(v) = Ai(p) + Ao(q),

and keep all other vertex weights unchanged. Let the composite pin set be (P \ {p}) U(Q \ {q}) U {vu}. Then the
MWIS solutions of G are logically equivalent on the composite pin set to the conjunction Ly A Lo.
The copy gadget, considered in this work, is constructed from an even number of NOT gadgets according to
Proposition 2} which naturally results in an odd-length vertex wire of 2n + 1 atoms with boundary atoms assigned
weight 6 and interior atoms weight 26 (see Figure b)) [86]. Under the strong Rydberg blockade, ideally no
two adjacent atoms are simultaneously excited. In the Q2/A — 0 limit, the lowest-energy configurations of the
odd-length wire form a two-fold degenerate Zy-ordered pair: |0)¢ = |0101...010), |1)~¢ = |1010...101) [37]. These
two logical states encode a binary variable indicating whether the corresponding graph vertex is excluded (0) or
included (1) in the MWIS.

Proposition 3. All odd-indezed vertices in a copy gadget are logically equivalent to the corresponding vertex in the
original graph.

Ill. GRAPH ENCODING METHODOLOGY:
FROM ARBITRARY GRAPHS TO UDGS ON TRIANGULAR-LATTICE SUBGRAPHS (TLSGS)

Given an arbitrary simple graph G = (V, E£) with vertex set V and edge set E, our objective is to construct an
encoding into a weighted unit-disk graph on a TLSG (see Fig. such that the maximum (weighted) independent
set problem on the original graph can be reduced to the MWIS problem on the encoded graph.

To address this challenge, we introduce the crossing lattice framework as in the KSG encoding [21]. In this
approach, each logical vertex is represented as a vertex wire (copy gadget), arranged so that every pair of logical
vertices intersects at exactly one crossing. This design propagates local adjacency relations along dedicated paths,
ensuring that only pairwise interactions need to be physically realized at each intersection. Each edge in the
original graph is represented by a crossing-with-edge gadget at intersections, while non-adjacent vertex pairs are
either handled by crossing gadgets or remain unconnected.

We then present a systematic approach for encoding arbitrary graphs into TLSGs through the construction of
crossing lattices. As described in Section [I] indices are assigned on a square-grid representation for convenience,
whereas the physical coordinates and distances are consistently interpreted on the triangular lattice via the mapping
convention.

III.A. Step 1: Construct Crossing Lattice

To construct the crossing lattice, we use L-shaped copy lines as the geometric scaffold. Each copy line specifies
the horizontal and vertical spans of an L-shaped wire assigned to a logical vertex. Arranged so that any two vertices
intersect at most once, these wires faithfully reproduce the adjacency of the original graph. Finally, each copy line
is populated with an odd-length copy gadget, turning the abstract scaffold into a physical vertex wire.

The complete graph A’, provides a concrete illustration of this procedure. As shown in Fig. [S3{a) and the table
below, different colored copy lines determine the placement of vertex wires and their intersections, and physical
sites are then populated along each line. These slots partition the grid into cells, with size s = 6 for the TLSG and
s =4 for the KSG. After vertices are placed at the subdivided grid points, each copy line forms an odd-length copy
gadget.

At each crossing between the copy gadgets of vertices u and v, we introduce an edge if (u,v) € E. In the
Hamiltonian, such an edge corresponds to a hard constraint term oo ny Ny.

III.B. Step 2: Gadget replacement

Identify and replace invalid substructures. The dashed boxes in Fig. [S3{a) highlight local substructures of the
crossing lattice that violate UDG constraints in the TLSG after Step 1. These regions are extracted and replaced
with logically equivalent gadgets, determined by the logical rules of the boundary pin vertices. When performing

Vertex] Vertical slot | Vertical range] Horizontal slot | Horizontal range
i / / 1 [1, 4]

2 2 (1, 2] 2 (2, 4]

4 4 [1, 4] [ [

10

Vertex 1

Vertex 4

FIG. $3. (a) Construction of the crossing lattice from copy lines for the complete graph Ky (before gadget replacement).
Dark gray lines denote copy line slots, each colored wire represents a vertex of the original graph, red-framed sites mark the
vertices logically equivalent to the originals, and red edges encode the original graph’s connectivity. Dashed boxes highlight
some regions violating TLSG constraints. (b) The crossing lattice shown in physical coordinates after gadget replacement
and fine-tuning. The number of auxiliary atoms can be further optimized, for example by manually removing dangling legs.

replacement, the weights of pin vertices connected to external structures must be updated according to Proposition}
Details of the replacement are shown in Fig.
Apply geometric fine-tuning. Replacement gadgets often differ in size and pin placement from the originals, so
additional adjustments are required (see Fig. . Fine-tuning consists of bending, extending, or shortening copy
gadgets to maintain connectivity and ensure consistent pin-vertex alignment. Wires may need to detour sideways
to preserve the parity of each wire. The resulting layout after replacement and fine-tuning is shown in Fig. [S3[>).
Adjust verter weights with detuning shifts. If an original vertex v; carries a weight w;, this can be renormalized
and transferred to the encoding by adding a small detuning shift ¢; at the corresponding logically equivalent vertex,
with e; x w;, subject to the requirement that it is large enough to lift unwanted degeneracies but small enough
not to disturb the d-scale constraints. Even for unweighted MIS instances, a small nonzero ¢€ is added to break
unwanted degeneracies. For a single copy gadget, such a detuning acts as a symmetry-breaking perturbation: it
lifts the degeneracy between the two MWIS states without affecting the Zz ordering of the wire.

Optimize for compactness. Although the encoding is complete after gadget replacement and fine-tuning, further
optimization can reduce resource overhead. Dangling vertex wires may be removed, and copy gadgets shortened,
provided that parity constraints are respected. At present, such optimization needs to be performed manually.

Finalize by reshaping to the triangular lattice. The last step maps the square-grid representation onto the
physical triangular lattice using the procedure in Section[]] This reshaping preserves all unit-disk edges and requires
no further adjustments. For readout, the measurement outcome may be taken from any logically equivalent vertex
along a vertex wire.

III.C. Overhead Analysis

For a graph with n vertices and m edges, the TLSG encoding scheme produces an encoding containing Nyisc
vertices, given approximately by

n(in-—1
Nrusa § 6n(n — 1) + 4mrignt + 1 (mM — mtop — Mrignt) +4 ( ( 5} ) m) (82)

~ 8n? — 6n — 3m,
11

(a) Crossing gadget (b) Crossing-with-edge gadget

(c) T-connection gadgets

(d) Other substructures to be fine-tuned

O ee Q O

o—® _— © Overlapping vertices

O g—® White-framed vertices indicate ancilla
O O Weights: © 6 ©25 @35 @45
O-O

FIG. S4. Illustration of the gadget replacement and fine-tuning procedure. The dashed boxes indicate regions where gadgets
are directly replaced. Fine-tuning is applied after replacement to ensure proper integration with the existing structure,
subject to two constraints: (1) the parity of the number of atoms on each vertex-wire is preserved, and (2) no additional
connections are introduced beyond those that already exist. Red-framed vertices indicate the logical counterparts on the
corresponding vertex wires, and white-framed vertices inside each gadget have no logical role and function solely as ancillas.

where 6 is the size of the cross-lattice cell s (see Figure a)), 4 the ancilla vertex count of the rightmost T-
connection gadget, 1 that of the crossing-with-edge gadget, 4 that of the crossing gadget, mrignt, Mtop <n — 1
denote the numbers of edges intersecting the rightmost and topmost copy lines, respectively.

This analysis indicates that our method requires at most O(8n) atoms, whereas the encoding overhead on the
KSG is at most O(4n?) [21] [29]. This estimate is rather coarse, as it does not account for potential optimizations
such as vertex reordering after encoding.

III.D. Code Availability and Usage

We build upon the existing Julia package UnitDiskMapping.jl [31], which reduces generic maximum (weighted)
independent set, QUBO, or integer factorization problems to KSG formulations. In this work, we extend the
package by introducing a new module that encodes generic MIS/MWIS instances directly onto TLSGs, enabling
natural implementation on neutral-atom quantum computers. The updated codebase, along with usage examples
and documentation, is openly available at [31].

Here, we take the complete graph 4 as an example to demonstrate how to use the code. The entire encoding
workflow, though conceptually involving many steps, has been fully encapsulated, so that a single function call
suffices to perform the whole process.
12

Weights: O6 © 26 @ 36 @ 46 @ Pin vertex

FIG. $5. Encoding of the Petersen graph onto a TLSG. Vertex color indicates weight. Vertices in the original graph correspond
to the red-framed vertices. Membership in the original graph’s independent set is inferred by projective measurement of the
corresponding red-framed vertex in the lattice.

julia> using UnitDiskMapping, Graphs

julia> graph = complete_graph(4)
{4, 6} undirected simple Int64 graph

julia> triangular_weighted_res = map_graph(TriangularWeighted(), graph) ;

The result can then be visualized, producing plots such as those shown in Fig.
Petersen graph is shown in Fig.

b). A larger example using the

julia> using LuxorGraphPlot.Luxor, LuxorGraphPlot
julia> show_grayscale(triangular_weighted_res.grid_graph) # Visualize weighted graph with colors

julia> show_pins(triangular_weighted_res) # Highlight pin vertices in the encoding graph

The code also provides APIs to verify the correctness of the encoding results; for detailed usage, please refer to
the documentation.

13

Algorithm 1: Graph Traversal and Logic Constraint Matching Search Process

Input : Graph set to search G; logic rules £ (e.g., truth table of a Boolean function)
Output: Set S of graphs and corresponding weight configurations that satisfy £

So; // Initialize the solution set as empty
foreach G € G do
M + MaximalIndependentSets(G) ; // Compute maximal independent sets
O + GetOpenNodes(G) ; // Get candidate nodes that can serve as pins
foreach pins € GeneratePinConfigs(O,M,L) do
Myin <— GetProperMIS(M, pins, £) ; // Select MISs that satisfy the logic rule

if Min is empty then
L. continue

IP + FormulateIP(M, Mmin, pins, £) ; // Formulate a mixed-integer program
if Solve(IP) is feasible then
A + ExtractWeights(IP.solution) ; // Extract vertex weights
S¢SU{(G, pins, A)} ; // Record the current solution
return S

IV. DETAILS OF THE SEARCH ALGORITHM

In this section, we describe how, given a logical rule £, one can construct or search for a graph G = (V, £) along
with positive vertex weights {A, | v € V} such that the solution to the MWIS problem on this graph corresponds
to the given logical rule. Such a graph is what we previously referred to as a gadget which maps a discrete set of
states to the energy-minimizing solution of a combinatorial optimization problem.

IV.A. Preliminaries

Definition 3 (Maximal Independent Set). A mazimal independent set is an independent set that is not a proper
subset of any other independent set.

In other words, a maximal independent set S satisfies the following condition: adding any vertex not in S would
violate its independence, i.e.,

Vu €V\S, du € S such that (u,v) € £. (S3)

Proposition 4 (MWIS is maximal). For any positive-weighted graph G = (V,E,A), a mazimum weighted inde-
pendent set is always a maximal independent set.

Proof. Suppose there exists a maximum weighted independent set S that is not maximal. Then there exists a
vertex u € V \ S that is not adjacent to any vertex in S. In this case, SU {u} forms a larger independent set with
total weight A(S) + A(u) > A(S), which contradicts the assumption that S is maximum weighted. Therefore, a
maximum weighted independent set must be maximal.

As we will see in the following sections, the concepts of maximal and MWIS form the foundation for constructing
gadgets: by carefully selecting maximal independent sets and assigning vertex weights, we can encode logical rules
into the MWIS problem on unit-disk graphs.

IV.B. Search algorithm

To find gadgets that satisfy the desired properties within a constrained graph dataset G (e.g., TLSGs), we design
a systematic search procedure, as outlined in Algorithm [I]

Step 1: Solving maximal independent sets M For each candidate graph G = (V, E) € G, all maximal cliques in
the complement graph G can be found using the Bron-Kerbosch algorithm [38], which corresponds to all maximal
independent sets M on G. The set of maximal independent sets M can be represented as a |M| x |V| binary
matrix, where each row corresponds to a maximal independent set n € {0, IVI and each column corresponds to a
vertex vu; in the graph.
14

Step 2: Selecting target maximal independent sets Mmin GC M based on £L In our encoding scheme, pin ver-
tices—representing logical variables at gadget boundaries—are chosen from the open boundary vertices. We first
identify the candidate set of pin vertices O. Given the logical rule £ and the set of maximal independent sets M,
the algorithm then enumerates all possible ordered pin configurations within O, which determine how logical bits
are mapped onto gadget vertices.

Let the target configuration set for £ = {s1,s2,...,sn}, where each s; € {0,1}*, k < |V|. For a fixed pin
configuration, a maximal independent set is said to satisfy s; if its configuration values on the pin vertices exactly
match s;.

Accordingly, for each target configuration s;, one can define the candidate set of maximal independent sets
Ms, C M. If Ms,,.-.,;Msy are all non-empty, then Min is non-empty, indicating that the vertex configuration
possibly encodes the logical rule £. As the number of ancilla vertices increases, the number of maximal independent
sets also grows, so the selection of Min satisfying £ is generally not unique.

Step 3: Formulating the integer programming problem For any vertex configuration with a non-empty Mymin, the
algorithm formulates the integer programming problem IP defined in main text:

min Aj

acny “F

Sonidi< Soni: Va € Minin, 0! €M\ Mynin (84)
a a

SonAi= Soni Ai, Vn, n! € Mnin-
7

a

As stated in the main text, vertex weights should be non-negative. In particular, if an optimal solution assigns a
weight of zero to a vertex, it implies that the corresponding vertex in the resulting gadget can be removed.

In conclusion, the constraints in the IP are determined by the graph topology, the pin choice, and the logical
rule. If the IP has a feasible solution—i.e., there exists a set of vertex weights A such that the graph under this
configuration correctly encodes £—then the graph, pin choice, and vertex weights are considered a valid solution
and stored in the final solution set.

TABLE S1. Examples of gadgets on the triangular lattice

Logic Gnas Pin ; WIS Logic Gaaeet Pin : MWIS
gate configuration energy gate configuration energy

AND 000, 010, 100,111 3 XOR 000, 011,101,110 4

NAND 001, 011,101,110 4 NOR oGire 001, 010,100,110 3

OR 000, 011,101,111 4

@ Pin vertex Weights: O 6 O 26
IV.C. Code Availability and Usage

We developed a Julia package, GadgetSearch.jl [33], for systematically searching gadgets in graph structures. The
package provides tools to find weighted graphs whose MWIS solutions encode arbitrary logical constraints. It is
suitable for TLSGs in this work.

Using this systematic search method, Table [S1]shows examples of gadgets on TLSGs that implement the logical
rules of AND, NAND, OR, NOR, and XOR gates. These gadgets are not unique. The code used to generate these
gadgets is provided below; for detailed usage, please refer to the documentation.

julia> using GadgetSearch, Gurobi, Combinatorics

julia> const env = Gurobi.Env() # can be replaced with other solvers

julia> truth_table = BitMatrix.([
[0 00; 101; 0141; 111], # OR
[0 00; 100; 010; 11 1], # AND
[0 0 1; 101; 011; 1 10], # NAND = not(AND)
[0 0 1; 100; 010; 11 0], # NOR = not(OR)
[00 0; 101; 014; 1 10] # XOR

1)
julia> generate_full_grid_udg(Triangular(), 2, 2; path="dataset.g6")
julia> dataloader = GraphLoader("dataset.g6") # you can provide your own graph datasets

julia> results, failed = search_by_truth_tables(
dataloader,
truth_table;
optimizer=Gurobi.Optimizer,
env=env,
pin_candidates=collect (Combinatorics.combinations(1:4, 3)),
objective=x->sum(x)

V. NUMERICAL SIMULATION SETUP

To quantitatively evaluate the performance of our TLSG encoding, we simulate quantum annealing dynamics
and benchmark against the established KSG encoding for the mapped K23 graph. The simulations are designed
to closely replicate experimental conditions in Ref. [20] while remaining computationally tractable. We employ the
time-dependent variational principle (TDVP) [39] with a matrix product state (MPS) ansatz.

Annealing performance is quantified by the violation rate p,, defined from the final measurement outcomes of
hy) as

A. .
P= Do Pla) YI mu, Pla) = [dnles)P, (88)
n€{0,1}!IV! (u,v)EE
where n = (71,.--, yj) denotes a bit-string configuration with n; € {0,1} indicating whether vertex v; € V is

excited. Smaller p, corresponds to stronger enforcement of independence constraints.

The annealing protocol follows standard experimental practice [20], employing an unoptimized piecewise-linear
pulse (see main text Fig. 3(b)). All atoms are initialized in the ground state. The Rabi frequency (7) ramps
from 0 to Qmax and back to 0, while the detuning A(r) sweeps from —Amax to Amax over the total annealing time
7 € [0,T]. Key parameters are:

e Maximum Rabi frequency: Qmax = 27 x 4 MHz,

e Maximum detuning: Amax = 5 X OQmax-

The blockade radius R, is defined as the distance at which the van der Waals interaction equals the maximum
Rabi frequency, Co/RE = OQmax With Cg = 27 x 862690 MHz jxm®. To map the Rydberg blockade onto the unit-disk

16
graph representation, we choose the lattice spacing a (also the unit-disk radius) such that

Rip = Resse cies (S6)

where Rin and Tmax are the minimum distance between disconnected atoms and the maximum distance between
connected atoms in the unit-disk graph. This sets the blockade radius at the geometric mean of these bounds,
ensuring blockade for connected pairs while avoiding spurious long-range interactions [40]. For the two lattice types
considered, we have:

KSG: Rmin = 20, Tmax=V2a => a=279/4R,,
TLSG: Rin = V30, Tmax=a => a=3-/4R,.

Time evolution is simulated using the time-dependent variational principle (TDVP) [39] with a matrix product
state (MPS) ansatz, a maximum bond dimension y = 256, and a time step of 0.107}, © 0.004ys. To accurately
capture non-local interactions and geometric frustration in the Rydberg Hamiltonian, we employ a two-site TDVP
scheme with third-order global subspace expansion (GSE) [41]. After the bond dimension is saturated, we switch

to one-site TDVP without GSE for computational efficiency.
